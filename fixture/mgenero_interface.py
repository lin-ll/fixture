import yaml
from fixture.run import path_relative
import os
from fault import RealKind
from magma import Array

'''
A parameter file for mgenero looks like this:

{for test:
    { for dv: # an example of dv is 'dcgain' or 'fz1'
        [for true digital modes:
            {'mode': 'modename' # 'dummy_digitalmode' is common
             'coef': { for term:
                 'term_name' : value # term name might be 'offset'
             }
            }
        ]
    }
}
'''


def binary(x, y):
    return [(x//(i+1))%2 for i in range(y)]

def dump_yaml(dut, params_by_mode):
    d = {}
    for mode, params in params_by_mode.items():
        for param, terms in params.items():
            if len(params_by_mode) == 1:
                mode_dict = {'dummy_digitalmode': 0}
            else:
                # mode dict keys are true digital pins
                names = [dut.get_name(p) for p in dut.inputs_true_digital]
                mode_dict = {name:x for name,x in zip(names, binary(mode, len(names)))}
            coefs_by_mode = d.get(param, [])
            coefs_this_mode = {
                    'mode': mode_dict,
                    'coef': terms
                }
            coefs_by_mode.append(coefs_this_mode)
            d[param] = coefs_by_mode

    #print('hello', d['gain'][0]['mode'])

    final = {'test1':d}
    return yaml.dump(final)

def create_interface(circuit, collateral_dict):


    def my_in(p, ps):
        ''' computes (p in ps) without importing mantle '''
        for p2 in ps:
            if p is p2:
                return True
        return False

    def create_pin(p, spice_name):
        d = {}
        # key for this whole dict is template name, value for key "name" is spice name
        d['name'] = spice_name
        d['description'] = str(p)
        # TODO inout?
        d['direction'] = 'input' if not p.isinput() else 'output'
        # pwl
        # logic can mean true digital or clock ...
        # vectorsize is # bits
        # Let's assume pwl for real and logic for digital/ba
        isreal = isinstance(type(p), RealKind)
        d['datatype'] = 'pwl' if isreal else 'logic'
        d['is_optional'] = my_in(p, (circuit.inputs_optional + circuit.inputs_pinned))

        # TODO array of reals?
        if isinstance(p, Array):
            d['vectorsize'] = len(p)

        return d

    # mapping from fixture template name to spice name
    pin_name_mapping = {}
    for template_port_name in circuit.required_ports:
        template_port = getattr(circuit, template_port_name)
        # TODO use the mgenero template name for the key
        pin_name_mapping[template_port] = template_port.name.name

    pins = {}
    for p_name, _ in circuit.IO.items():
        p = getattr(circuit, p_name)
        spice_name = pin_name_mapping.get(p_name, p_name)
        pins[spice_name] = create_pin(p, spice_name)

    interface = {}
    interface['pin'] = pins
    interface['module_name'] = 'placeholder'
    interface['template_name'] = 'placeholder'
    interface['description'] = 'placeholder'
    interface['modelparam'] = collateral_dict['modelparam']

    cfg = {}
    cfg['pin'] = pins
    cfg['module_name'] = circuit.name

    interface_text = yaml.dump(interface)
    cfg_text = yaml.dump(cfg)
    return interface_text, cfg_text
    


def create_all(circuit, config, params):
    # TODO:
    params_text = dump_yaml(circuit, params)
    interface_text, circuit_text = create_interface(circuit, config)
    generate_text = get_generate_text(config['template_name'])
    directory = config['build_folder']

    with open(os.path.join(directory, 'params.yaml'), 'w') as f:
        f.write(params_text)
    with open(os.path.join(directory, 'circuit.cfg'), 'w') as f:
        f.write(circuit_text)
    with open(os.path.join(directory, 'interface.yaml'), 'w') as f:
        f.write(interface_text)
    with open(os.path.join(directory, 'generate.py'), 'w') as f:
        f.write(generate_text)

def get_generate_text(template_name):
    text = f''' # autogenerated
from dave.mgenero.mgenero import ModelCreator
config = 'circuit.cfg'
interface = 'interface.yaml'
template = '{template_name}'
params = 'params.yaml'
intermediate = 'template.intermediate.sv'
output = 'final.sv'

m = ModelCreator(config, interface)
m.generate_model(template, intermediate)
m.backannotate_model(intermediate, output, params)
    '''
    return text
    
    
