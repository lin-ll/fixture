BIT_WIDTH = 4
LENGTH = 2
VDD = 1.2 # for switch thresholds
ZERO_IS_LOW_ORDER = True
Z_DEBUG = 'ss_noisy'
NOISE_RMS = 0.01

d = 'D'
w = 'W'
outp = 'outp'
outn = 'outn'
vdd = 'vdd'
vss = 'vss'
name = 'my_mac'


switch_models = []
one_bit_multiply = []
scale_and_add = []
diff_conversion = []
noise = []

sm1 = f'.model MUL_SW      SW(Ron=1 Roff=1000000 Vt={3*VDD/2} Vh=-0.1)'
sm2 = f'.model MUL_SW_INV  SW(Ron=1000000 Roff=1 Vt={3*VDD/2} Vh=-0.1)'
sm3 = f'.model DIFF_SW     SW(Ron=1 Roff=1000000 Vt={VDD})'
sm4 = f'.model DIFF_SW_INV SW(Ron=1000000 Roff=1 Vt={VDD})'
switch_models += [sm1, sm2, sm3, sm4]


inout = []
for word in range(LENGTH):
    for bit in range(BIT_WIDTH):
        suffix = '<%d><%d>' % (word, bit)
        inout.append(f'{d}{suffix}')
        inout.append(f'{w}{suffix}')
inout += [outp, outn, vdd, vss]
if Z_DEBUG is not None:
    inout.append('z_debug')
inout.sort()
subckt = [f'.subckt {name} {" ".join(inout)}']
end_subckt = ['.ends']

debug_sum = 0
prev_sum = vss
for word in range(LENGTH):
    for data_bit in range(BIT_WIDTH):
        for weight_bit in range(BIT_WIDTH):
            suffix = '<%d><%d><%d>' % (word, data_bit, weight_bit)
            suffix_d = '<%d><%d>' % (word, data_bit)
            suffix_w = '<%d><%d>' % (word, weight_bit)

            # create mul<><> which is the 1-bit product d<><>*w<><>
            m1 = f'Emul_vcvs_{suffix} mul_temp_ideal{suffix} d{suffix_d} {w}{suffix_w} {vss} 1'
            m5 = f'Rmul_nonideal{suffix} mul_temp_ideal{suffix} mul_temp{suffix} 1'
            m2 = f'Smul_sw_{suffix}     {vss} mul{suffix} mul_temp{suffix} {vss} MUL_SW'
            m3 = f'Smul_sw_inv_{suffix} {vdd} mul{suffix} mul_temp{suffix} {vss} MUL_SW_INV'
            m4 = f'Cmul_temp_{suffix} mul_temp{suffix} {vss} 100p'
            m6 = f'Cmul_{suffix} mul{suffix} {vss} 100p'

            # scale 1-bit product accordingly
            max_value_word = 2 / LENGTH
            # TODO I think this should be 2**BIT_WIDTH-1 to utilize full range?
            value_low_bit = max_value_word / ((2**BIT_WIDTH-1)**2)

            assert ZERO_IS_LOW_ORDER
            value_this_bit = 2**(data_bit + weight_bit) * value_low_bit
            #print(max_value_word, value_low_bit, value_this_bit)
            #debug_sum += value_this_bit
            #s0 = f'\n* Using value {value_this_bit / value_low_bit} for d{data_bit}, w{weight_bit}'
            s1 = f'Emul_scale_{suffix} mul_scaled{suffix} {vss} mul{suffix} {vss} {value_this_bit}'

            # sum
            current_sum = f'sum{suffix}'
            s2 = f'Esum_{suffix} {current_sum} {prev_sum} mul_scaled{suffix} {vss} 1'
            prev_sum = current_sum

            one_bit_multiply += [m1, m5, m2, m3, m4, m6]
            scale_and_add += [s1, s2]
#print('total', debug_sum)
single_sided = prev_sum

# single_sided spans from 0 tp 2*VDD, with VDD representing 0
d1 = f'Ediff_pos diff_pos {vss} ss_noisy {vdd} 1'
d2 = f'Ediff_neg diff_neg {vss} ss_noisy {vdd} -1'
d3 = f'Sdiff_outp1 {outp} {vss}    ss_noisy {vss} DIFF_SW_INV'
d4 = f'Sdiff_outp2 {outp} diff_pos ss_noisy {vss} DIFF_SW'
d5 = f'Sdiff_outn1 {outn} diff_neg ss_noisy {vss} DIFF_SW_INV'
d6 = f'Sdiff_outn2 {outn} {vss}    ss_noisy {vss} DIFF_SW'

diff_conversion += [d1, d2, d3, d4, d5, d6]

# noise
#n1 = f'Bnoise noise {vss} V=white(1000000*time)'
n1 = f'Vnoise noise {vss} trnoise(1, 1e-6, 0, 0)'
n2 = f'Enoise ss_noisy {single_sided} noise {vss} {NOISE_RMS}'
noise += [n1, n2]

total = [
    (f'Subcircuit definition for {name}', subckt),
    ('Switch Models', switch_models),
    ('One bit multiply', one_bit_multiply),
    ('Scale and add', scale_and_add),
    ('Add white noise', noise),
    ('Single-ended to differential conversion', diff_conversion),
    (f'End subcircuit for {name}', end_subckt)
]

if Z_DEBUG is not None:
    total.insert(5, ('Debug output', [f'Rdebug z_debug {Z_DEBUG} 0.1\nCdebug z_debug {vss} 100p']))

text = f'*** AUTOGENERATED by {__file__} ***'
for comment, lines in total:
    text += f'\n\n* {comment}\n'
    text += '\n'.join(lines)
text += '\n'

print(text)


