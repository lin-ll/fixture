BIT_WIDTH = 4
LENGTH = 2
VDD = 1.2 # for switch thresholds
ZERO_IS_LOW_ORDER = True

d = 'D'
w = 'W'
outp = 'outp'
outn = 'outn'
vdd = 'vdd'
vss = 'vss'
name = 'my_mac'


switch_models = []
one_bit_multiply = []
scale_and_add = []
diff_conversion = []

sm1 = f'.model MUL_SW      SW(Ron=1 Roff=1000 Vt={VDD/2})'
sm2 = f'.model MUL_SW_INV  SW(Ron=1000 Roff=1 Vt={VDD/2})'
sm3 = f'.model DIFF_SW     SW(Ron=1 Roff=1000 Vt={VDD})'
sm4 = f'.model DIFF_SW_INV SW(Ron=1000 Roff=1 Vt={VDD})'
switch_models += [sm1, sm2, sm3, sm4]


inout = []
for word in range(LENGTH):
    for data_bit in range(BIT_WIDTH):
        for weight_bit in range(BIT_WIDTH):
            suffix = '<%d><%d><%d>' % (word, data_bit, weight_bit)
            inout.append(f'{d}{suffix}')
            inout.append(f'{w}{suffix}')
inout += [outp, outn, vdd, vss]
inout.sort()
subckt = [f'subckt {name} {" ".join(inout)}']
end_subckt = ['.ends']

for word in range(LENGTH):
    for data_bit in range(BIT_WIDTH):
        prev_sum = vss
        for weight_bit in range(BIT_WIDTH):
            suffix = '<%d><%d><%d>' % (word, data_bit, weight_bit)

            # create mul<><> which is the 1-bit product d<><>*w<><>
            m1 = f'Emul_vcvs_{suffix} mul_temp{suffix} d{suffix} {w}{suffix} {vss} 1'
            m2 = f'Smul_sw_{suffix} vdd mul{suffix} mul_temp{suffix} {vss} MUL_SW'
            m3 = f'Smul_sw_{suffix} vdd mul{suffix} mul_temp{suffix} {vdd} MUL_SW_INV'

            # scale 1-bit product accordingly
            max_value_word = 2*VDD / LENGTH
            # TODO I think this should be 2**BIT_WIDTH-1 to utilize full range?
            value_low_bit = max_value_word / ((2**BIT_WIDTH)**2)

            assert ZERO_IS_LOW_ORDER
            value_this_bit = 2**(data_bit + weight_bit) * value_low_bit
            s1 = f'Emul_scale_{suffix} mul_scaled{suffix} vss mul{suffix} {vss} {value_this_bit}'

            # sum
            current_sum = f'sum{suffix}'
            s2 = f'Esum_{suffix} {current_sum} {prev_sum} mul_scaled{suffix} {vss} 1'
            prev_sum = current_sum

            one_bit_multiply += [m1, m2, m3]
            scale_and_add += [s1, s2]

single_sided = prev_sum

# single_sided spans from 0 tp 2*VDD, with VDD representing 0
d1 = f'Ediff_pos diff_pos {vss} {single_sided} {vdd} 1'
d2 = f'Ediff_neg diff_neg {vss} {single_sided} {vdd} -1'
d3 = f'Sdiff_outp1 {outp} {vss}    {single_sided} {vss} DIFF_SW_INV'
d4 = f'Sdiff_outp2 {outp} diff_pos {single_sided} {vss} DIFF_SW'
d5 = f'Sdiff_outn1 {outn} diff_neg {single_sided} {vss} DIFF_SW_INV'
d6 = f'Sdiff_outn2 {outn} {vss}    {single_sided} {vss} DIFF_SW'

diff_conversion += [d1, d2, d3, d4, d5, d6]


total = [
    (f'Subcircuit definition for {name}', subckt),
    ('Switch Models', switch_models),
    ('One bit multiply', one_bit_multiply),
    ('Scale and add', scale_and_add),
    ('Single-ended to differential conversion', diff_conversion),
    (f'End subcircuit for {name}', end_subckt)
]

text = f'*** AUTOGENERATED by {__file__} ***'
for comment, lines in total:
    text += f'\n\n* {comment}\n'
    text += '\n'.join(lines)
text += '\n'

print(text)


