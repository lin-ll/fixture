
/****************************************************************
* This code is automatically generated by "mGenero"
* at Tue, 04 Feb 2020 17:21:55.
*
* Copyright (c) 2014-Present by Stanford University. All rights reserved.
*
* The information and source code contained herein is the property
* of Stanford University, and may not be disclosed or reproduced
* in whole or in part without explicit written authorization from
* Stanford University.
* For more information, contact bclim@stanford.edu
****************************************************************/
/****************************************************************

Copyright (c) 2018 Stanford University. All rights reserved.

The information and source code contained herein is the 
property of Stanford University, and may not be disclosed or
reproduced in whole or in part without explicit written 
authorization from Stanford University.

* Filename   : amplifier.template.sv
* Author     : Byongchan Lim (bclim@stanford.edu)
* Description: SV template for an amplifier cell

* Note       :

* Todo       :
  - 

* Revision   :
  - 00/00/00 : 

****************************************************************/
/*******************************************************
* An amplifier with possible output equalization
* - Input referred voltage offset as a static parameter
* - Gain Compression
* - Dynamic behavior (a pole or two-poles with a zero)
* - 

* Calibrating metrics:
* 1. Av = gm*Rout 
* 2. Max output swing = Itail*Rout 
* 3. fp1, fp2, fz1
*******************************************************/

module amplifier123 #(
  abc123
  <bound method type.parameters of <class 'Module'>>
  got the first one ok
  parameter real etol_vdd = 0.01, // resolution of vdd
  parameter real etol_v_icm = 0.01, // resolution of input common-mode voltage (inp+inn)/2.0
  parameter real v_os = 0.0, // input-referred static offset voltage
  parameter real etol_f = 0.0001 // error tolerance of a filter
) (
  input pwl inn , // Input to comparator
  input pwl inp , // Input to comparator
  output pwl outn , // none
  output pwl outp , // none
  input pwl vdd , // power supply
  input pwl vss  // ground
);

`protect
//pragma protect 
//pragma protect begin

`get_timeunit
PWLMethod pm=new;

// map pins between generic names and user names, if they are different
 
//----- BODY STARTS HERE -----

//----- SIGNAL DECLARATION -----
pwl ONE = `PWL1;
pwl ZERO = `PWL0;

pwl v_id_lim;   // limited v_id 
pwl v_oc; // output common-mode voltage
pwl v_od; // output differential voltage
pwl vid_max, vid_min; // max/min of v_id for slewing 
pwl vop, von;
pwl v_od_filtered;
pwl vop_lim, von_lim;
pwl v_id, v_icm; // differential and common-mode inputs

real t0;
real v_icm_r;
real vdd_r;
real vss_r;

real fz1, fp1, fp2; // at most, two poles and a zero
real Av;    // voltage gain (gm*Rout)
real max_swing; // Max voltage swing of an output (Itail*Rout)
real vid_r; // vid<|vid_r| (max_swing/Av)
real v_oc_r;  // common-mode output voltage

event wakeup;

//----- FUNCTIONAL DESCRIPTION -----

initial ->> wakeup; // dummy event for ignition at t=0

//-- Compute differential and common-mode voltages 

  pwl _v_id[3]; pwl _v_icm[2]; real _k_v_id[3]; real _k_v_icm[2];
  assign _k_v_id = '{1.0, -1.0, v_os};
  assign _k_v_icm = '{0.5, 0.5};
  assign _v_id = '{inp, inn, ONE};
  assign _v_icm = '{inp, inn};
// diff/cm sense considering input referred offset
pwl_add #(.no_sig(3)) xidiff (.in(_v_id), .scale(_k_v_id), .out(v_id));
pwl_add #(.no_sig(2)) xicm (.in(_v_icm), .scale(_k_v_icm), .out(v_icm));

//-- System's parameter calculation

// discretization of control inputs
pwl2real #(.dv(etol_v_icm)) xp2r_v_icm (.in(v_icm), .out(v_icm_r)); // pwl-to-real of v_icm
pwl2real #(.dv(etol_vdd)) xp2r_vdd (.in(vdd), .out(vdd_r)); // pwl-to-real of vdd

// updating parameters as control inputs/mode inputs change

always @(v_icm_r, vdd_r, wakeup, vss_r) begin
  t0 = `get_time;

$${
digital_modes = [get_lm_equation_modes('test1', 'dcgain'), get_lm_equation_modes('test3', 'v_oc')]
digital_cases = [digital_modes[0][0].keys(), digital_modes[1][0].keys()]
variable_map = {'v_icm': 'v_icm_r'}
}$$

$$[if not mode_exists('test1')]
  Av = $$get_lm_equation('test1', 'dcgain');
$$[else]
  case({$$(','.join(digital_cases[0]))})
$$[for m in digital_modes[0]]
  {$$(','.join(["%d'b%s" % (Pin.vectorsize(d), dec2bin('%d'%m[d], Pin.vectorsize(d))) for d in digital_cases[0]]))}: begin
    Av = $$get_lm_equation('test1', 'dcgain', m);
  end
$$[end for]
  default: begin
    Av = $$get_lm_equation('test1', 'dcgain', digital_modes[0][0]);
  end
  endcase
$$[end if]

$$[if not mode_exists('test3')]
  v_oc_r = $$get_lm_equation('test3', 'v_oc');
$$[else]
  case({$$(','.join(digital_cases[1]))})
$$[for m in digital_modes[1]]
  {$$(','.join(["%d'b%s" % (Pin.vectorsize(d), dec2bin('%d'%m[d], Pin.vectorsize(d))) for d in digital_cases[1]]))}: begin
    v_oc_r = $$get_lm_equation('test3', 'v_oc', m);
  end
$$[end for]
  default: begin
    v_oc_r = $$get_lm_equation('test3', 'v_oc', digital_modes[1][0]);
  end
  endcase
$$[end if]

end

//-- Model behaviors

assign v_id_lim = v_id; // gain compression is not implemented

pwl_vga xgain (.in(v_id_lim), .scale(Av), .out(v_od)); // differential-mode gain stage 

assign v_od_filtered = v_od;  // filtering behavior is not implemented

real2pwl #(.tr(10e-12)) r2poc (.in(v_oc_r), .out(v_oc)); // output common-mode voltage

// combine differential and common-mode output
  pwl _v_od[2]; real _k_v_od_1[2]; real _k_v_od_2[2];
  assign _v_od = '{v_oc, v_od_filtered};

  assign _k_v_od_1 = '{1.0, 0.5};
  assign _k_v_od_2 = '{1.0, -0.5};
pwl_add #(.no_sig(2)) xoutp (.in(_v_od), .scale(_k_v_od_1), .out(outp));
pwl_add #(.no_sig(2)) xoutn (.in(_v_od), .scale(_k_v_od_2), .out(outn));

//pragma protect end
`endprotect

endmodule
