
@{
execfile("/home/dstanley/research/DaVE/dave/mgenero/api_mgenero.py")}@

@{
lm_param = {'test1': {'dcgain': [{'mode': {'dummy_digitalmode': 0}, 'coef': {'dans_pin*dans_pin': 42, 'offset': 0.7071497}}]}}

def mode_exists(testname): # return False if there is only 'dummy_digitalmode' in a test, testname
  param = globals()['lm_param']
  response = param[testname][param[testname].keys()[0]][0]
  if response['mode'].keys()==['dummy_digitalmode']:
    return False
  else:
    return True

def get_lm_coef(testname, dv, iv, mode={'dummy_digitalmode':0}):
  ''' 
      testname: test name
      dv: generic output response name (metric) 
      iv: generic analog control input in test.cfg
      mode: dict of true digital input vector in test.cfg
  '''
  param = globals()['lm_param']
  if dv in param[testname].keys():
    for v in param[testname][dv]:
      if v['mode']==mode:
        if iv in v['coef'].keys():
          return v['coef'][iv]
        else:
          return None
    return None
  else:
    return None

def get_terms(testname, dv, mode={'dummy_digitalmode':0}):
  ''' return a list of terms for dependent variable dv 
      Note that A, B, A:B are all different terms
  '''
  param = globals()['lm_param']
  if dv in param[testname].keys():
    for v in param[testname][dv]:
      if v['mode']==mode:
        return v['coef'].keys()
    return None
  else:
    return None

def get_lm_equation_modes(testname, dv):
  ''' return a list of a dictionary where the dictionary is a mode '''
  param = globals()['lm_param'][testname][dv]
  return [k['mode'] for k in param]

def replace_lm_variable_name(t):
  ''' replace variable name in linear equation by looking up variable_map if exists '''
  if t in variable_map.keys():
    return variable_map[t]
  elif Pin.is_exist(t):
    if Pin.datatype(t) == 'pwl':
      return PWL.get_real(t)
    else:
      return t
  else:
    return t

def get_lm_equation(testname, dv, mode={'dummy_digitalmode':0}, default='0.0'):
  ''' return a linear equation of dv as a function of inputs
      note that there is a suffix of '_r' for every independent variable in the resultant equation
      of which pin has a datatype of pwl
  '''
  try:
    import re
    from dave.common.misc import flatten_list
    param = globals()['lm_param']
    _terms = get_terms(testname, dv, mode) # terms from linear regression
    _coefs = [get_lm_coef(testname, dv, iv, mode) for iv in _terms]
  
    def get_unit_terms(term):
      ''' extact variables. For example, ctl1*ctl2 will produce [ctl1,ctl2] '''
      return [f for f in term.split('*') if len(f) >0 and f[0].isalpha()]
  
    _port = sorted(list(set(flatten_list([get_unit_terms(t) for t in _terms]))-set(['offset']))) # all the unit independent variables from linear regression results
    _varl = [replace_lm_variable_name(t) for t in _port]
  
    equation = '+'.join(['%s*%s' %(str(_coefs[i]),t) if t!='offset' else str(_coefs[i]) for i,t in enumerate(_terms)]).replace('+-','-')
    for i,v in enumerate(_port):
      equation = re.sub(r'\b%s\b' % v, _varl[i], equation)
    return equation
  except:
    return default


}@

/****************************************************************
* This code is automatically generated by "mGenero"
* at Mon, 27 Jan 2020 18:53:28.
*
* Copyright (c) 2014-Present by Stanford University. All rights reserved.
*
* The information and source code contained herein is the property
* of Stanford University, and may not be disclosed or reproduced
* in whole or in part without explicit written authorization from
* Stanford University.
* For more information, contact bclim@@stanford.edu
****************************************************************/
/****************************************************************

Copyright (c) 2018 Stanford University. All rights reserved.

The information and source code contained herein is the 
property of Stanford University, and may not be disclosed or
reproduced in whole or in part without explicit written 
authorization from Stanford University.

* Filename   : amplifier.template.sv
* Author     : Byongchan Lim (bclim@@stanford.edu)
* Description: SV template for an amplifier cell

* Note       :

* Todo       :
  - 

* Revision   :
  - 00/00/00 : 

****************************************************************/
/*******************************************************
* An amplifier with possible output equalization
* - Input referred voltage offset as a static parameter
* - Gain Compression
* - Dynamic behavior (a pole or two-poles with a zero)
* - 

* Calibrating metrics:
* 1. Av = gm*Rout 
* 2. Max output swing = Itail*Rout 
* 3. fp1, fp2, fz1
*******************************************************/

module amplifier123 #(
  abc123
  <bound method type.parameters of <class 'Module'>>
  got the first one ok
  parameter real etol_vdd = 0.01, // resolution of vdd
  parameter real etol_v_icm = 0.01, // resolution of input common-mode voltage (inp+inn)/2.0
  parameter real v_os = 0.0, // input-referred static offset voltage
  parameter real etol_f = 0.0001 // error tolerance of a filter
) (
  input pwl inn , // Input to comparator
  input pwl inp , // Input to comparator
  output pwl outn , // none
  output pwl outp , // none
  input pwl vdd , // power supply
  input pwl vss  // ground
);

`protect
//pragma protect 
//pragma protect begin

`get_timeunit
PWLMethod pm=new;

// map pins between generic names and user names, if they are different
 
//----- BODY STARTS HERE -----

//----- SIGNAL DECLARATION -----
pwl ONE = `PWL1;
pwl ZERO = `PWL0;

pwl v_id_lim;   // limited v_id 
pwl v_oc; // output common-mode voltage
pwl v_od; // output differential voltage
pwl vid_max, vid_min; // max/min of v_id for slewing 
pwl vop, von;
pwl v_od_filtered;
pwl vop_lim, von_lim;
pwl v_id, v_icm; // differential and common-mode inputs

real t0;
real v_icm_r;
real vdd_r;
real vss_r;

real fz1, fp1, fp2; // at most, two poles and a zero
real Av;    // voltage gain (gm*Rout)
real max_swing; // Max voltage swing of an output (Itail*Rout)
real vid_r; // vid<|vid_r| (max_swing/Av)
real v_oc_r;  // common-mode output voltage

event wakeup;

//----- FUNCTIONAL DESCRIPTION -----

initial ->> wakeup; // dummy event for ignition at t=0

//-- Compute differential and common-mode voltages 

  pwl _v_id[3]; pwl _v_icm[2]; real _k_v_id[3]; real _k_v_icm[2];
  assign _k_v_id = '{1.0, -1.0, v_os};
  assign _k_v_icm = '{0.5, 0.5};
  assign _v_id = '{inp, inn, ONE};
  assign _v_icm = '{inp, inn};
// diff/cm sense considering input referred offset
pwl_add #(.no_sig(3)) xidiff (.in(_v_id), .scale(_k_v_id), .out(v_id));
pwl_add #(.no_sig(2)) xicm (.in(_v_icm), .scale(_k_v_icm), .out(v_icm));

//-- System's parameter calculation

// discretization of control inputs
pwl2real #(.dv(etol_v_icm)) xp2r_v_icm (.in(v_icm), .out(v_icm_r)); // pwl-to-real of v_icm
pwl2real #(.dv(etol_vdd)) xp2r_vdd (.in(vdd), .out(vdd_r)); // pwl-to-real of vdd

// updating parameters as control inputs/mode inputs change

always @@(v_icm_r, vdd_r, wakeup, vss_r) begin
  t0 = `get_time;

@{
digital_modes = [get_lm_equation_modes('test1', 'dcgain'), get_lm_equation_modes('test3', 'v_oc')]
digital_cases = [digital_modes[0][0].keys(), digital_modes[1][0].keys()]
variable_map = {'v_icm': 'v_icm_r'}
}@

@[if not mode_exists('test1')]
  Av = @get_lm_equation('test1', 'dcgain');
@[else]
  case({@(','.join(digital_cases[0]))})
@[for m in digital_modes[0]]
  {@(','.join(["%d'b%s" % (Pin.vectorsize(d), dec2bin('%d'%m[d], Pin.vectorsize(d))) for d in digital_cases[0]]))}: begin
    Av = @get_lm_equation('test1', 'dcgain', m);
  end
@[end for]
  default: begin
    Av = @get_lm_equation('test1', 'dcgain', digital_modes[0][0]);
  end
  endcase
@[end if]

@[if not mode_exists('test3')]
  v_oc_r = @get_lm_equation('test3', 'v_oc');
@[else]
  case({@(','.join(digital_cases[1]))})
@[for m in digital_modes[1]]
  {@(','.join(["%d'b%s" % (Pin.vectorsize(d), dec2bin('%d'%m[d], Pin.vectorsize(d))) for d in digital_cases[1]]))}: begin
    v_oc_r = @get_lm_equation('test3', 'v_oc', m);
  end
@[end for]
  default: begin
    v_oc_r = @get_lm_equation('test3', 'v_oc', digital_modes[1][0]);
  end
  endcase
@[end if]

end

//-- Model behaviors

assign v_id_lim = v_id; // gain compression is not implemented

pwl_vga xgain (.in(v_id_lim), .scale(Av), .out(v_od)); // differential-mode gain stage 

assign v_od_filtered = v_od;  // filtering behavior is not implemented

real2pwl #(.tr(10e-12)) r2poc (.in(v_oc_r), .out(v_oc)); // output common-mode voltage

// combine differential and common-mode output
  pwl _v_od[2]; real _k_v_od_1[2]; real _k_v_od_2[2];
  assign _v_od = '{v_oc, v_od_filtered};

  assign _k_v_od_1 = '{1.0, 0.5};
  assign _k_v_od_2 = '{1.0, -0.5};
pwl_add #(.no_sig(2)) xoutp (.in(_v_od), .scale(_k_v_od_1), .out(outp));
pwl_add #(.no_sig(2)) xoutn (.in(_v_od), .scale(_k_v_od_2), .out(outn));

//pragma protect end
`endprotect

endmodule
